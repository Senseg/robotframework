#!/usr/bin/env python

# Copyright 2008-2010 Nokia Siemens Networks Oyj
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Packaging script for Robot Framework

Usage:  package.py command version_number [release_tag]

Argument 'command' can have one of the following values:
  - sdist    : create source distribution
  - wininst  : create Windows installer
  - all      : create both packages
  - version  : update only version information in 'src/robot/version.py'
  - jar      : create stand-alone jar file containing RF and Jython

'version_number' must be a version number in format '2.x(.y)', 'trunk' or
'keep'. With 'keep', version information is not updated.

'release_tag' must be either 'alpha', 'beta', 'rc' or 'final', where all but
the last one can have a number after the name like 'alpha1' or 'rc2'. When
'version_number' is 'trunk', 'release_tag' is automatically assigned to the
current date.

When creating the jar distribution, jython.jar must be placed in 'ext-lib'
directory, under the project root.

This script uses 'setup.py' internally. Distribution packages are created
under 'dist' directory, which is deleted initially. Depending on your system,
you may need to run this script with administrative rights (e.g. with 'sudo').

Examples:
  package.py sdist 2.0 final
  package.py wininst keep
  package.py all 2.1.13 alpha
  package.py sdist trunk
  package.py version trunk
"""

import sys
import os
import shutil
import re
import time
import subprocess
import zipfile
from glob import glob


ROOT_PATH = os.path.abspath(os.path.dirname(__file__))
DIST_PATH = os.path.join(ROOT_PATH, 'dist')
BUILD_PATH = os.path.join(ROOT_PATH, 'build')
ROBOT_PATH = os.path.join(ROOT_PATH, 'src', 'robot')
JAVA_SRC_ROOT = os.path.join(ROOT_PATH, 'src', 'java')
JAVA_PKG = ('org', 'robotframework')
JYTHON_JAR = glob(os.path.join(ROOT_PATH, 'ext-lib', 'jython-standalone-*.jar'))[0]
SETUP_PATH = os.path.join(ROOT_PATH, 'setup.py')
VERSION_PATH = os.path.join(ROBOT_PATH, 'version.py')
VERSIONS = [re.compile('^2\.\d+(\.\d+)?$'), 'trunk', 'keep']
RELEASES = [re.compile('^alpha\d*$'), re.compile('^beta\d*$'),
            re.compile('^rc\d*$'), 'final']
VERSION_CONTENT = """# Automatically generated by 'package.py' script.
import sys


VERSION = '%(version_number)s'
RELEASE = '%(release_tag)s'
TIMESTAMP = '%(timestamp)s'

def get_version(sep=' '):
    if RELEASE == 'final':
        return VERSION
    return VERSION + sep + RELEASE

def get_full_version(who=''):
    interpreter   =  sys.platform.startswith('java') and 'Jython' or 'Python'
    syversion = sys.version.split()[0]
    vers = '%%s %%s (%%s %%s on %%s)' %% (who, get_version(), interpreter,
                                         syversion, sys.platform)
    return vers.strip()

if __name__ == '__main__':
    print get_version(*sys.argv[1:])
"""

def sdist(*version_info):
    version(*version_info)
    _clean()
    _create_sdist()
    _announce()

def wininst(*version_info):
    version(*version_info)
    _clean()
    if _verify_platform(*version_info):
        _create_wininst()
        _announce()

def all(*version_info):
    version(*version_info)
    _clean()
    _create_sdist()
    if _verify_platform(*version_info):
        _create_wininst()
    _announce()

def version(version_number, release_tag=None):
    _verify_version(version_number, VERSIONS)
    if version_number == 'keep':
        _keep_version()
    elif version_number =='trunk':
        _update_version(version_number, '%d%02d%02d' % time.localtime()[:3])
    else:
        _update_version(version_number, _verify_version(release_tag, RELEASES))
    from version import get_version
    return get_version(sep='-')

def _verify_version(given, valid):
    for item in valid:
        if given == item or (hasattr(item, 'search') and item.search(given)):
            return given
    raise ValueError

def _update_version(version_number, release_tag):
    timestamp = '%d%02d%02d-%02d%02d%02d' % time.localtime()[:6]
    vfile = open(VERSION_PATH, 'w')
    vfile.write(VERSION_CONTENT % locals())
    vfile.close()
    print 'Updated version to %s %s' % (version_number, release_tag)

def _keep_version():
    sys.path.insert(0, ROBOT_PATH)
    from version import get_version
    print 'Keeping version %s' % get_version()

def _clean():
    print 'Cleaning up...'
    for path in [DIST_PATH, BUILD_PATH]:
        if os.path.exists(path):
            shutil.rmtree(path)

def _verify_platform(version_number, release_tag=None):
    if release_tag == 'final' and os.sep != '\\':
        print 'Final Windows installers can only be created in Windows.'
        print 'Windows installer was not created.'
        return False
    return True

def _create_sdist():
    _create('sdist', 'source distribution')

def _create_wininst():
    _create('bdist_wininst', 'Windows installer')
    if os.sep != '\\':
        print 'Warning: Windows installers created on other platforms may not'
        print 'be exactly identical to ones created in Windows.'

def _create(command, name):
    print 'Creating %s...' % name
    rc = os.system('%s %s %s' % (sys.executable, SETUP_PATH, command))
    if rc != 0:
        print 'Creating %s failed.' % name
        sys.exit(rc)
    print '%s created successfully.' % name.capitalize()

def _announce():
    print 'Created:'
    for path in os.listdir(DIST_PATH):
        print os.path.abspath(os.path.join(DIST_PATH, path))

def jar(*version_info):
    ver = version(*version_info)
    _compile_java_classes()
    _create_jar_distribution(ver)

def _compile_java_classes():
    source_path = os.path.join(JAVA_SRC_ROOT, *JAVA_PKG)
    source_files = [ os.path.join(source_path, f) for f
                     in os.listdir(source_path) if f.endswith('java') ]
    print 'Compiling %d source files' % len(source_files)
    subprocess.call(['javac', '-cp', JYTHON_JAR]  + source_files)

def _create_jar_distribution(version):
    tmpdir = _create_tmpdir()
    _copy_files_to(tmpdir)
    _create_manifest(tmpdir, version)
    jar_path = _create_jar_file(version)
    _fill_jar(tmpdir, jar_path)
    shutil.rmtree(tmpdir)
    print 'Created %s based on %s' % (jar_path, JYTHON_JAR)

def _create_tmpdir():
    tmpdir = os.path.join(ROOT_PATH, 'tmp-jar-dir')
    if os.path.exists(tmpdir):
        shutil.rmtree(tmpdir)
    os.mkdir(tmpdir)
    return tmpdir

def _copy_files_to(tmpdir):
    for srcdir, todir in [(ROBOT_PATH,
                           os.path.join(tmpdir, 'Lib', 'robot')),
                          (os.path.join(JAVA_SRC_ROOT, *JAVA_PKG),
                           os.path.join(tmpdir, 'org', 'robotframework'))]:
        # pyc files must be excluded so that compileall works properly.
        shutil.copytree(srcdir, todir, ignore=shutil.ignore_patterns('*.pyc*'))
    subprocess.call(['java', '-jar', JYTHON_JAR, '-m', 'compileall', tmpdir])

def _create_manifest(tmpdir, version):
    mffile = os.path.join(tmpdir, 'META-INF', 'MANIFEST.MF')
    os.mkdir(os.path.dirname(mffile))
    open(mffile, 'w').write('''Manifest-Version: 1.0
Main-Class: org.robotframework.RobotFramework
Specification-Version: 2
Implementation-Version: %s''' % version)

def _create_jar_file(version):
    jar_path = os.path.join(DIST_PATH, 'robotframework-%s.jar' % version)
    if not os.path.exists(DIST_PATH):
        os.mkdir(DIST_PATH)
    for path in [os.path.join(DIST_PATH, name) for name in os.listdir(DIST_PATH)]:
        if path.endswith('.jar'):
            print 'removing old jarfile', path
            os.remove(path)
    shutil.copyfile(JYTHON_JAR, jar_path)
    return jar_path

def _fill_jar(tmpdir, jar_path):
    jar = zipfile.ZipFile(jar_path, 'a')
    for dirname in ('Lib', 'org', 'META-INF'):
        _copy_files_to_jar(tmpdir, dirname, jar)
    jar.close()

def _copy_files_to_jar(tmpdir, dirname, jar):
    for root, _, files in os.walk(os.path.join(tmpdir, dirname)):
        for name in files:
            if not name.endswith(('.class', '.MF')):
                continue
            source = os.path.join(root, name)
            target = source.replace(tmpdir+os.sep, '')
            print 'Adding %s' % target
            jar.write(source, target)


if __name__ == '__main__':
    try:
        globals()[sys.argv[1]](*sys.argv[2:])
    except (KeyError, IndexError, TypeError, ValueError):
        print __doc__

