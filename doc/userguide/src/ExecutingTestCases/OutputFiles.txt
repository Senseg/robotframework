Created outputs
---------------

Several output files are created when tests are executed, and all of
them are somehow related to test results. This section discusses what
outputs are created, how to configure where they are created, and how
to fine-tune their contents.

.. contents::
   :depth: 2
   :local:

Different output files
~~~~~~~~~~~~~~~~~~~~~~

This section explains what different output files can be created and
how to configure where they are created. Output files are configured
using command line options, which get the path to the output file in
question as an argument. A special value :opt:`NONE`
(case-insensitive) can be used to disable creating a certain output
file.

Output directory
''''''''''''''''

All output files can be set using an absolute path, in which case they
are created to the specified place, but in other cases, the path is
considered relative to the output directory. The default output
directory is the directory where the execution is started from, but it
can be altered with the :opt:`--outputdir (-d)` option. The path
set with this option is, again, relative to the execution directory,
but can naturally be given also as an absolute path. Regardless of how
a path to an individual output file is obtained, its parent directory
is created automatically, if it does not exist already.

Output file
'''''''''''

Output files contain all the test execution results in XML
format. Log_, report_, and summary_ files are generated based on
output files, and output files can also be `combined and otherwise
post-processed`__ after the test execution.

The command line option :opt:`--output (-o)` determines where
output files are created. Output files are always created when tests
are executed, and unless outputs are `splitted`__, only one output file 
is created. The default name for the output file is :path:`output.xml`.
If outputs are splitted to several output files, they are named by 
postfixing the name of the first output file with sequence numbers. When 
post-processing outputs, new output files are not created unless 
:opt:`--output (-o)` option is explicitly used.

__ `Post-processing outputs`_

__ `Splitting outputs`_

Log file
''''''''

Log files contain details about the executed test cases in HTML
format. They have a hierarchical structure showing test suite, test
case and keyword details. Log files are needed nearly every time when
test results are to be investigated in detail. Even though log files
also have statistics, report_ and summary_ files are better for
getting an higher-level overview.

The command line option :opt:`--log (-l)` determines where log
files are created. Unless the special value :opt:`NONE` is used,
log files are always created and their default name is
:path:`log.html`.

.. figure:: src/ExecutingTestCases/log_passed.png
   :target: src/ExecutingTestCases/log_passed.html
   :width: 500

   An example of beginning of a log file

.. figure:: src/ExecutingTestCases/log_failed.png
   :target: src/ExecutingTestCases/log_failed.html
   :width: 500

   An example of a log file with keyword details visible

Report file
'''''''''''

Report files contain an overview of the test execution results in HTML
format. They have statistics based on tags and executed test suites,
as well as a list of all executed test cases. When both reports and
logs are generated, the report has links to the log file for easy
navigation to more detailed information.  It is easy to see the
overall test execution status from report, because its background
color is green, if all `critical tests`_ pass, and bright red
otherwise.

The command line option :opt:`--report (-r)` determines where
report files are created. Similarly as log files, reports are always
created unless :opt:`NONE` is used as a value, and their default
name is :path:`report.html`.

.. figure:: src/ExecutingTestCases/report_passed.png
   :target: src/ExecutingTestCases/report_passed.html
   :width: 500

   An example report file of successful test execution

.. figure:: src/ExecutingTestCases/report_failed.png
   :target: src/ExecutingTestCases/report_failed.html
   :width: 500

   An example report file of failed test execution

Summary file
''''''''''''

Summary files contain the same statistics as reports, and their
background color is similarly green or red, depending on the overall
test execution status. However, they have no test case details, which
makes them much smaller. They are useful when a large number of test
cases is executed and a very high-level overview is needed.

Summary files are not generated by default. When they are needed, they
can be created using the command line option :opt:`--summary
(-S)`.

.. figure:: src/ExecutingTestCases/summary_passed.png
   :target: src/ExecutingTestCases/summary_passed.html
   :width: 350

   An example summary file

Debug file
''''''''''

Debug files are plain text files that are written during the test
execution. All messages got from test libraries are written to them,
as well as information about started and ended test suites, test cases
and keywords. Debug files can be used for monitoring the test
execution. This can be done using, for example, a separate `file
viewing tool`_, or in UNIX-like systems, simply with the :prog:`tail
-f` command.

Debug files are not created unless the command line option
:opt:`--debugfile (-b)` is used explicitly.

Timestamping output files
'''''''''''''''''''''''''

All output files listed in this section can be automatically
timestamped with the option :opt:`--timestampoutputs (-T)`, which
is one of the rare options taking no value. When this option is used, a
timestamp in the format :opt:`YYYYMMDD-hhmmss` is placed between
the extension and the basename of each file. The example below would,
for example, create such output files as
:path:`output-20080604-163225.xml` and
:path:`mylog-20080604-163225.html`.

::

   pybot --timestampoutputs --log mylog.html --report NONE tests.html

Setting titles
''''''''''''''

The default titles for log_, report_ and summary_ files are generated
by prefixing the name of the top-level test suite wtih :name:`Test
Log`, :name:`Test Report` or :name:`Summary Report`. Custom titles can
be given from the command line using the options
:opt:`--logtitle`, :opt:`--reporttitle` and
:opt:`--summarytitle`, respectively. With all these options,
underscores in the given title are converted to spaces automatically.

Examples::

   pybot --logtitle Smoke_Test_Log --reporttitle Smoke_Test_Report --include smoke mytests
   rebot --summarytitle Overview --summary overview.html --log none --report none *.xml

Setting background colors
'''''''''''''''''''''''''

By default the `report file`_ and the `summary file`_ have a green
background when all the `critical tests`_ pass and a red background
otherwise.  These colors can be customized by using the
:opt:`--reportbackground` command line option, which takes two or
three colors separated with a colon as an argument::

   --reportbackground blue:red
   --reportbackground green:yellow:red
   --reportbackground #00E:#E00

If you specify two colors, the first one will be used instead of the
default green color and the second instead of the default red. This
allows, for example, using blue instead of green to make backgrounds
easier to separate for color blind people.

If you specify three colors, the first one will be used when all the
test succeed, the second when only non-critical tests have failed, and
the last when there are critical failures. This feature thus allows
using a separate background color, for example yellow, when
non-critical tests have failed.
	
The specified colors are used as a value for the :code:`body`
element's :code:`background` CSS property. The value is used as-is and
can be a HTML color name (e.g. :code:`red`), a hexadecimal value
(e.g. :code:`#F00`), or an RGB value (e.g. :code:`rgb(255,0,0)`. The
default green and red colors are specified using hexadecimal
values :code:`#9F6` and :code:`#F33`, respectively.

Log levels
~~~~~~~~~~

Available log levels
''''''''''''''''''''

Messages in `log files`_ can have different log levels. Some of the
messages are written by Robot Framework itself, but also executed
keywords can `log information`__ using different levels. The available
log levels are:

:msg:`FAIL`
   Used when a keyword fails. Can be used only by Robot Framework itself.

:msg:`WARN`
   Used to display warnings. They shown also in `the console and in
   the Test Execution Errors section in log files`__, but they
   do not affect the test case status.
 
:msg:`INFO` 
   The default level for normal messages. By default,
   messages below this level are not shown in the log file.

:msg:`DEBUG`
   Used for debugging purposes. Useful, for example, for
   logging what libraries are doing internally. When a keyword fails,
   a traceback showing where in the code the failure occurred is
   logged using this level automatically.

:msg:`TRACE`
   More detailed debugging level. The keyword arguments and return values
   are automatically logged using this level.

__ `Logging information`_
__ `Errors and warnings during execution`_

Setting log level
'''''''''''''''''

By default, log messages below the :msg:`INFO` level are not logged, but this
threshold can be changed from the command line using the
:opt:`--loglevel (-L)` option. This option takes any of the
available log levels as an argument, and that level becomes the new
threshold level. A special value :msg:`NONE` can also be used to
disable logging altogether.

Starting from Robot Framework 2.5.2, it is possible to use the
:opt:`--loglevel` option also when `post-processing outputs`_ with
:prog:`rebot`. This allows, for example, running tests initially with
the :msg:`TRACE` level, and generating smaller log files for normal
viewing later with the :msg:`INFO` level. By default all the messages
included during execution will be included also with :prog:`rebot`.
Messages ignored during the execution cannot be recovered.

Another possibility to change the log level is using the `BuiltIn
keyword`_ :name:`Set Log Level` in the test data. It takes the same
arguments as the :opt:`--loglevel` option, and it also returns the
old level so that it can be restored later, for example, in a `test
teardown`_.

Splitting outputs
~~~~~~~~~~~~~~~~~

Benefits
''''''''

When executing a large number of test cases, the size of log files can
increase to the extent that opening them into a browser is
slow. Additionally, since log files can be created only after output
files are ready, they are available only after the test
execution. This is not a problem if the test execution time is short,
but with long-running tests it is better to be able to investigate
the first failures while the rest of the tests are still running.

Splitting outputs provides a solution for both of these
problems. First of all, splitting logs means that individual log files
are smaller and thus faster to open. If outputs are split while
executing test cases, the lower-level log files are also created
immediately when the equivalent output files are ready. Notifications
about created files can be received through the `listener
interface`_, and `automatic variables`_ :var:`${LOG_FILE}` and
:var:`${OUTPUT_FILE}` always contain the path to the current file.

Specifying a split level
''''''''''''''''''''''''

Outputs are split from a certain test suite level. Suites below this
level will get their own outputs, and everything above the level will
be in an index file, which has links to lower-level files. Only
`output files`_ and `log files`_ are split, and they are always split
from the same level. Splitting outputs gives the best results when test
cases are organized into a relatively balanced hierarchical structure.

Splitting can be activated with the command line option
:opt:`--splitoutputs`, which takes the split level as an
argument. Index files have the same name as the output and log would have
without splitting, and lower-level files get a running counter between
the basename and extension.

Examples
''''''''

Explaining how splitting outputs actually works is easiest with
examples, and it is also a good idea to experiment with real test data.
In these examples we assume that test cases are organized into test
suites hierarchically in the following way::

   project
   |-- component_a
   |   |-- feature_a1
   |   |   |-- a11.html
   |   |   `-- a12.html
   |   `-- feature_a2
   |       `-- a21.html
   |-- component_b
   |   `-- feature_b1
   |       |-- b11.html
   |       `-- b21.html
   `-- component_c
       |-- c1.html
       |-- c2.html
       `-- c3.html

In the first example these test cases are executed so that they are
split right below the top-level test suite. The command line to use is
as follows, and the following table lists all the created output files::

   pybot --splitoutputs 1 project

.. table:: All output files created in the first example
   :class: tabular

   +---------------+-------------------------------------------------------+ 
   | Created File  |                       Contents                        |
   +===============+=======================================================+
   | output.xml    | Information about the :name:`Project` test suite,     |
   |               | excluding its child test suites. Lower-level output   |
   |               | files are referenced.                                 |
   +---------------+-------------------------------------------------------+ 
   | output-001.xml| Information about the whole :name:`Component A` suite.|
   +---------------+-------------------------------------------------------+ 
   | output-002.xml| Information about the whole :name:`Component B` suite.|
   +---------------+-------------------------------------------------------+ 
   | output-003.xml| Information about the whole :name:`Component C` suite.|
   +---------------+-------------------------------------------------------+ 
   | log.html      | A log file created from :path:`output.xml`,           |
   |               | lower-level log files are linked.                     |
   +---------------+-------------------------------------------------------+ 
   | log-001.html  | A log file created from :path:`output-001.xml`.       |
   +---------------+-------------------------------------------------------+ 
   | log-002.html  | A log file created from :path:`output-002.xml`.       |
   +---------------+-------------------------------------------------------+ 
   | log-003.html  | A log file created from :path:`output-003.xml`.       |
   +---------------+-------------------------------------------------------+ 
   | report.html   | A normal report file.                                 |
   +---------------+-------------------------------------------------------+ 

The fact that output files are split is transparent when
post-processing outputs afterwards, and it is enough to point
:prog:`rebot` to the index file. Splitting works with :prog:`rebot`
regardless of whether outputs are split earlier or not. Outputs created by the
first example could thus by re-split, for example, as::

   rebot --splitoutputs 2 output.xml

In this example, splitting is done from the second level. The table below
again lists created the files, and because :prog:`rebot` does not create new
output files by default, they are not listed in the table.

.. table:: All output files created in the second example
   :class: tabular

   +---------------+-------------------------------------------------------+ 
   | Created File  |                       Contents                        |
   +===============+=======================================================+
   | log.html      | Information about the :name:`Project` and all the     |
   |               | :name:`Component ?` suites, but not their child       |
   |               | suites. Lower-level log files are linked.             |
   +---------------+-------------------------------------------------------+ 
   | log-001.html  | The whole :name:`Feature A1` test suite.              |
   +---------------+-------------------------------------------------------+ 
   | log-002.html  | The whole :name:`Feature A2` test suite.              |
   +---------------+-------------------------------------------------------+ 
   | log-003.html  | The whole :name:`Feature B1` test suite.              |
   +---------------+-------------------------------------------------------+ 
   | log-004.html  | The whole :name:`C1` test suite.                      |
   +---------------+-------------------------------------------------------+ 
   | log-005.html  | The whole :name:`C2` test suite.                      |
   +---------------+-------------------------------------------------------+ 
   | log-006.html  | The whole :name:`C3` test suite.                      |
   +---------------+-------------------------------------------------------+ 
   | report.html   | A normal report file.                                 |
   +---------------+-------------------------------------------------------+ 

The last example splits outputs from the third level. It also shows
how to configure output file names when splitting::

   rebot --splitoutputs 3 --log mylog.html --report none output.xml

.. table:: All output files created in the third example
   :class: tabular

   +---------------+-------------------------------------------------------+ 
   | Created File  |                       Contents                        |
   +===============+=======================================================+
   | mylog.html    | Information about the :name:`Project` test suite all  |
   |               | the way to its second-level child suites. This        |
   |               | includes test cases in the :name:`C?` suites.         |
   |               | Lower-level logs are linked.                          |
   +---------------+-------------------------------------------------------+ 
   | mylog-001.html| The whole :name:`A11` test suite.                     |
   +---------------+-------------------------------------------------------+ 
   | mylog-002.html| The whole :name:`A12` test suite.                     |
   +---------------+-------------------------------------------------------+ 
   | mylog-003.html| The whole :name:`A21` test suite.                     |
   +---------------+-------------------------------------------------------+ 
   | mylog-004.html| The whole :name:`B11` test suite.                     |
   +---------------+-------------------------------------------------------+ 
   | mylog-005.html| The whole :name:`B12` test suite.                     |
   +---------------+-------------------------------------------------------+ 

If a split level higher than three is used with this test data, all the
information ends up to index files. The end result is thus exactly the
same as if outputs were not split at all.

Configuring statistics
~~~~~~~~~~~~~~~~~~~~~~

There are several command line options that can be used to configure
and adjust the contents of the :name:`Statistics by Tag`, :name:`Statistics
by Suite` and :name:`Test Details by Tag` tables in different output
files. All these options work both when executing test cases and when
post-processing outputs.

Configuring displayed suite statistics
''''''''''''''''''''''''''''''''''''''

When a deeper suite structure is executed, showing all the test suite
levels in the :name:`Statistics by Suite` table may make the table
somewhat difficult to read. You can control the number of levels
displayed with the command line option :opt:`--suitestatlevel`. It
takes the required level as an integer, and if :opt:`0` is used,
the whole table is removed.

Including and excluding tag statistics
''''''''''''''''''''''''''''''''''''''

When many tags are used, the :name:`Statistics by Tag` table can become
quite congested. If this happens, the command line options
:opt:`--tagstatinclude` and :opt:`--tagstatexclude` can be
used to select which tags to display, similarly as
:opt:`--include` and :opt:`--exclude` are used to `select test
cases`__::

   --tagstatinclude some-tag --tagstatinclude another-tag
   --tagstatexclude owner-*
   --tagstatinclude prefix-* --tagstatexclude prefix-13

These settings affect also the :name:`Test Details by Tag` table, so
that it has details only by the selected tags. This can make the
report considerably smaller, which is why excluding tags that are not
interesting can be recommended.

__ `By tag names`_

Generating combined tag statistics
''''''''''''''''''''''''''''''''''

The command line option :opt:`--tagstatcombine` can be used to
generate aggregate tags that combine statistics from multiple
tags. These new combined tags are shown in the :name:`Statistics by
Tag` table, and the matching tests are listed in the :name:`Test
Details by Tag` table.  There are three somewhat different ways for
giving arguments for this option:

One tag as a `simple pattern`_
   All tags matching the given pattern are combined together.

Two or more tags separated by :code:`AND` or :code:`&`
   The combined statistics contain tests that have all the listed tags.
   Tags can be given as simple patterns.

Two or more tags separated by :code:`NOT`
   The combined statistics contain tests that have the first tag but
   not the others. Also in this case tags may be patterns.

The following examples illustrate these usages, and the figure below shows a snippet 
of the resulting :name:`Statistics by Tag` table when the example test data is 
executed with these options::

    --tagstatcombine owner-*
    --tagstatcombine smokeANDmytag
    --tagstatcombine smokeNOTowner-janne*

.. figure:: src/ExecutingTestCases/tagstatcombine.png
   :width: 550

   Examples of combined tag statistics

As the above example shows, the name of the added combined statistic is, by default,
generated from the given pattern. In certain situations this name can look pretty
cryptic and, starting from Robot Framework 2.0.2, it is possible to specify a 
more descriptive name. This name is given after the pattern separating it 
with a colon (:code:`:`). Example below generates combined tag so that the name shown
in reports and logs is :name:`Critical Tests`::

    --tagstatcombine *NOTnon-critical:Critical_Tests

Creating links from tag names
'''''''''''''''''''''''''''''

You can add external links to the :name:`Statistics by Tag` table by
using the command line option :opt:`--tagstatlink`. Arguments to this
option are given in the format :opt:`tag:link:name`, where :opt:`tag`
specifies the tags to assign the link to, :opt:`link` is the link to
be created, and :opt:`name` is the name to give to the link.

:opt:`tag` may be a single tag, but more commonly a `simple
pattern`_ where :code:`*` matches anything and :code:`?` matches any
single character. When :opt:`tag` is a pattern, the matches to
wildcards may be used in :opt:`link` with the syntax :code:`%N`,
where "N" is the index of the match starting from 1.

The following examples illustrate the usage of this option, and the
figure below shows a snippet of the resulting :name:`Statistics by
Tag` table when example test data is executed with these options::

    --tagstatlink mytag:http://www.google.com:Google
    --tagstatlink jython-bug-*:http://bugs.jython.org/issue_%1:Jython-bugs
    --tagstatlink owner-*:mailto:%1@domain.com?subject=Acceptance_Tests:Send_Mail

.. figure:: src/ExecutingTestCases/tagstatlink.png
   :width: 550

   Examples of links from tag names

Adding documentation to tags
''''''''''''''''''''''''''''

Tags can be given a documentation with the command line option
:opt:`--tagdoc`, which takes an argument in the format
:opt:`tag:doc`. "tag" is the name of the tag to assign
the documentation to, and it can also be a `simple pattern`_ matching
multiple tags. "doc" is the assigned
documentation. Underscores in it are converted to spaces automatically,
and it can also contain `HTML formatting`_. The given documentation is
shown with matching tags in the :name:`Test Details by Tag` table, and as
a tool tip for these tags in the :name:`Statistics by Tag` table.

Examples::

    --tagdoc mytag:My_documentation
    --tagdoc regression:*See*_http://info.html
    --tagdoc owner-*:Original_author

Additional options for post-processing outputs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

These options are available only when `post-processing outputs`_ with
:prog:`rebot`.

Setting times for combined outputs
''''''''''''''''''''''''''''''''''

When `combining outputs`_, it is possible to set the start and end
time of the combined test suite using the options
:opt:`--starttime` and :opt:`--endtime`, respectively. This is
convenient, because by default, combined suites do not have these
values. When both the start and end time are given, the elapsed time
is also calculated based on them. Otherwise the elapsed time is got by
adding the elapsed times of the child test suites together.

Times must be given as timestamps in the format :code:`YYYY-MM-DD
hh:mm:ss.mil`, where all separators are optional and the parts from
milliseconds to hours can be omitted. For example, :code:`2008-06-11
17:59:20.495` is equivalent both to :code:`20080611-175920.495` and 
:code:`20080611175920495`, and also mere :code:`20080611` would work.

Examples::

   rebot --starttime 20080611-17:59:20.495 output1.xml output2.xml
   rebot --starttime 20080611-175920 --endtime 20080611-180242 *.xml

Removing keywords from outputs
''''''''''''''''''''''''''''''

Most of the content of `output files`_ comes from keywords and
especially their log messages. When creating higher level reports, log
files are not necessarily needed at all, and then keywords and their
messages just take space unnecessarily. In these situations, the
command line option :opt:`--removekeywords` can be used to dispose
of unnecessary keywords. It has two possible values:

:opt:`ALL`
   All keywords are unconditionally removed. 

:opt:`PASSED`
   Keywords are removed only from the passed test cases. In most cases, log
   files created after this contain enough information to investigate
   possible failures.

Removing keywords makes output files considerably smaller and thus
faster to process further. Even when keywords are removed, names,
arguments and statuses of top-level keywords are preserved, so it is
still possible to create log files and see the high-level structure of
each test case. 

System log
~~~~~~~~~~

Robot Framework has its own plain-text system log where it writes
information about

   - Processed and skipped test data files
   - Imported test libraries, resource files and variable files
   - Executed test suites and test cases
   - Created outputs

Normally users never need this information, but it can be
useful when investigating problems with test libraries or Robot Framework
itself. A system log is not created by default, but it can be enabled
by setting the environment variable :opt:`ROBOT_SYSLOG_FILE` so
that it contains a path to the selected file.

A system log has the same `log levels`_ as a normal log file, with the
exception that instead of :msg:`FAIL` it has the :msg:`ERROR`
level. The threshold level to use can be altered using the
:opt:`ROBOT_SYSLOG_LEVEL` environment variable like shown in the
example below.  Possible `unexpected errors and warnings`__ are
written into the system log in addition to the console and the normal
log file.

.. sourcecode:: bash

   #!/bin/bash

   export ROBOT_SYSLOG_FILE=/tmp/syslog.txt
   export ROBOT_SYSLOG_LEVEL=DEBUG

   pybot --name Syslog_example path/to/tests

__ `Errors and warnings during execution`_
