Remote library interface
------------------------

Remote library interface provides means for having test libraries on
different machines than where Robot Framework is running, and also for
implementing libraries using other languages than the natively
supported Python and Java. For a test library user remote
libraries look pretty much the same as any other test library, and
developing test libraries using the Remote library interface is also
similar to creating `normal test libraries`__.

__ `Creating test libraries`_

.. contents:: 
   :depth: 2
   :local: 


Introduction
~~~~~~~~~~~~

Remote library interface is provided by Remote library that is one of
the `standard libraries`_ starting from Robot Framework 2.1. This
library does not have any keywords of its own, and it works as a proxy
to keywords implemented elsewhere. The Remote library communicates
with the actual library implementation using a simple `remote
protocol`_ on top of an `XML-RPC`_ channel.  The high level
architecture of Remote library is illustrated in the picture below:

.. figure:: src/ExtendingRobotFramework/remote.png

   Robot Framework architecture with Remote library

There are two main reasons for using the remote library API:

* It is possible to have actual libraries on different machines than
  where Robot Framework itself is running. This allows interesting
  possibilities for distributed testing.

* Test libraries can be implemented using any language that support
  XML-RPC protocol. Robot Framework 2.1 contains generic remote servers
  for Python/Jython and Ruby and it is possible to implement them for
  other languages too.


Taking Remote library into use
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When Remote library is taken into use, it needs to get an address of
the remote server as an argument, but otherwise importing it and using
keywords that it provides is no different to how other libraries are
used. If you need to use Remote library multiple times in a test
suite, or just want to give it a more describing name, you need to
import it using the `WITH NAME syntax`_.

.. table:: Importing Remote library using WITH NAME syntax
   :class: example

   =========  ===========  ======================  =========  =========
    Setting      Value              Value            Value      Value
   =========  ===========  ======================  =========  =========
   Library    Remote       \http://localhost:8270  WITH NAME  Example1
   Library    Remote       \http://10.0.0.42:7777  WITH NAME  Example2
   =========  ===========  ======================  =========  =========

The first URL used in the above examples is also the default address
that the Remote library uses if no address is given. Similarly port
:code:`8270` is the default port the provided remote servers use. (82
and 70 are the ASCII codes of letters `R` and `F`, respectively.)

Before the Remote library can be imported using a certain URL, the
remote server providing the actual keywords must be started. It is
possible to start the server before launching the test execution, or
other keywords, for example from OperatingSystem or SSH library, can
start it up. Notice that in the latter case you may need to import the
Remote library `using Import Library keyword`_.


Creating libraries on top of the remote server
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Robot Framework 2.1 includes remote server implementation written both in
`Python`__ and `Ruby`__.  A test library using the remote server must be
implemented so that it can be started from the command line.  When started, it
must start the remote server and register itself to it.

Below are simple example libraries implemented in Python and Ruby that
demonstrate how test libraries use the remote server.  There is also a simple
`test case file`__ that uses the keywords from these libraries. 

__ ../../tools/remotelibrary/robotremoteserver.py
__ ../../tools/remotelibrary/robotremoteserver.rb
__ ../../tools/remotelibrary/example/example.html


.. sourcecode:: python 

   ../../tools/remotelibrary/example/examplelibrary.py


.. sourcecode:: ruby 

   ../../tools/remotelibrary/example/examplelibrary.rb


.. include:: ../../../../tools/remotelibrary/example/README.txt


Remote protocol
~~~~~~~~~~~~~~~

This section explains the protocol that is used between the Remote
library and remote servers. This information is mainly targeted for
people who want to create new remote servers.

The remote protocol is implemented on top of the `XML-RPC`_ which is a
simple remote procedure call protocol. Most widely used languages
(Python, Java, C, Ruby, Perl, Javascript, PHP, ...) have a support for
XML-RPC and many even have the support built-in.

A remote server is an XML-RPC server that must have the same methods
as the `dynamic library API`_ has. Only :code:`get_keyword_names` and
:code:`run_keyword` are actually required, but
:code:`get_keyword_arguments` and :code:`get_keyword_documentation`
are also recommended. Notice that using camelCase format in method
names is not possible, but a support for that can be added later.
How the actual keywords are implemented is not relevant for the Remote
library.  A remote server can either act as a wrapper for real test
libraries, like the provided Python and Ruby servers do, or it can
implement keywords itself.


Getting remote keyword names
''''''''''''''''''''''''''''

The Remote library gets a list of keywords that the remote server
provides using :code:`get_keyword_names` method. This method must
return the keyword names as a list of strings.

Executing remote keywords
'''''''''''''''''''''''''

:code:`run_keyword`.

*TODO*

Getting remote keywords' arguments and documentation
''''''''''''''''''''''''''''''''''''''''''''''''''''

Remote servers can, and should, also implement
:code:`get_keyword_arguments` and :code:`get_keyword_documentation`
methods to provide more information about the keywords. Arguments must
be returned as a list of strings the same way with `dynamic
libraries`__. Documentation must be returned as a string, again the
same ways as with `dynamic libraries`__


__ `Getting keyword arguments`_
__ `Getting keyword documentation`_

