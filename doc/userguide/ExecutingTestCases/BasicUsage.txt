Basic usage
-----------

Robot Framework test cases are executed from the command line, and the
end result is, by default, an output file in XML format and a HTML
report and log. After the execution, output files can be combined and
otherwise post-processed with the :prog:`rebot` tool.

.. contents::
   :depth: 2
   :local:


Starting test execution
~~~~~~~~~~~~~~~~~~~~~~~

Different start-up scripts
''''''''''''''''''''''''''

Test execution is normally started with the :prog:`pybot` or :prog:`jybot`
commands, which are otherwise identical, but the former uses Python and
latter Jython. Which one to use depends on the needed test
libraries. Some libraries use modules or syntax available only on
Python, others use Java-based tools that require Jython, and some work
on both. If you can use either :prog:`pybot` or :prog:`jybot`, the
former is recommended, as Python is somewhat faster than Jython.

Another possibility for starting the test execution is running the
:prog:`runner.py` script under the installed__ :code:`robot` module
directly. This method allows selecting the interpreter and setting
command line options to it freely. The most common use case is
altering the options controlling JVM maximum memory consumption.

__ `Where files are installed`_

Regardless of the runner script, a path (or paths) to the test data to be
executed is given as an argument. Additionally, different command line
options can be used to alter the test execution or generated
outputs in some way.


Specifying the test data to be executed
'''''''''''''''''''''''''''''''''''''''

Robot Framework test cases are created in files__ and directories__,
and they are executed by giving the path to the file or directory in
question to the selected start-up script. The path can be absolute or,
more commonly, relative to the directory where tests are executed
from. The given file or directory creates the top-level test suite,
which gets its name, unless overridden with the :setting:`--name` option__,
from the `file or directory name`__. Different execution possibilities
are illustrated in the examples below. Note that in these examples, as
well as in other examples in this section, only the :prog:`pybot`
start-up script is used, but :prog:`jybot` or a custom runner script
could be used similarly.

__ `Test case files`_
__ `Test suite directories`_
__ `Setting name`_
__ `Test suite name and documentation`_

::

   pybot test_cases.html
   pybot path/to/my_tests/
   pybot /opt/robot/tests.html   
   pybot c:\robot\tests.html
   
It is also possible to give paths to multiple test case files or
directories at once, separated with spaces. In this case, Robot
Framework creates the top-level test suite automatically, and
the specified files and directories become its child test suites. The name
of the created test suite is got from child suite names so that they
are catenated together with an ampersand (&) and spaces. For example,
the name of the top-level suite in the first example below is
:name:`My Tests & Your Tests`. These automatically created names are
seldom very good and they can often be quite long. In most cases, it
is thus better to use the :setting:`--name` option for overriding it like
in the second example below::

   pybot my_tests.html your_tests.html
   pybot --name Example path/to/tests/pattern_*.html


Using command line options
''''''''''''''''''''''''''

Robot Framework provides a number of command line options that can be
used to control how test cases are executed. The syntax for using them
is explained in this section. What options actually exist and how
they can be used is discussed elsewhere in this chapter.

Options always have a long name, such as :setting:`--name`, and the
most frequently needed options also have a short name, such as
:setting:`-N`. In addition to that, long options can be shortened if
they are unique. For example, :cli:`--logle DEBUG` works, while
:cli:`--lo log.html` does not, because the former matches only
:setting:`--loglevel`, but the latter matches several options. Short
and shortened options are practical when executing test cases manually,
but long options are recommended in the start-up script, because they
are easier to understand. Finally, the long option format is
case-insensitive. For example, :setting:`--SuiteStatLevel` is
equivalent to, but easier to read than :setting:`--suitestatlevel`.

Most of the options require a value, which is given after the option
name. Both short and long options accept the value so that it is
separated from the option name with a space, as in :cli:`--include tag`
or :cli:`-i tag`. With long options, the separator can also be the
equals sign, as in :cli:`--include=tag`, and with short options the
separator can be omitted, as in :cli:`-itag`.

Some options can be specified several times. For example,
:cli:`--variable VAR1:value --variable VAR2:another` sets two
variables. If the options that take only one value are used several
times, the last given value is effective.

Many of the options take arguments as *simple patterns*. This means
that :code:`*` and :code:`?` can be used as special characters, so that
the former matches any string (even an empty string) and the latter
matches any single character. For example, :cli:`--include prefix-\*`
matches all tags starting with :code:`prefix-`, and :cli:`--include
a???` matches any tag that is four characters long and starts with an
:code:`a`.

Generated outputs
'''''''''''''''''

The most visible output from test execution is the output displayed in
the command line. All executed test suites and test cases as well as
their statuses are shown there in real time. the example below shows the
output from executing a simple test suite with only two test cases::

   ==============================================================================
   Example test suite
   ==============================================================================
   First test :: Possible documentation is here                          | PASS |
   ------------------------------------------------------------------------------
   Second test                                                           | FAIL |
   Error message is displayed here
   ==============================================================================
   Example test suite                                                    | FAIL |
   2 critical tests, 1 passed, 1 failed
   2 tests total, 1 passed, 1 failed
   ==============================================================================
   Output:  /path/to/output.xml
   Report:  /path/to/report.html
   Log:     /path/to/log.html


The command line output is very limited, and separate output files are
normally needed for investigating the test execution, if there are any
problems. Like the example above shows, three output files are
generated by default. The first one is in the XML format and it contains
all information about test execution. The second is a higher-level
report and the third is a more detailed log file, both in HTML format
and generated from the XML output. These files and other possible
output files are discussed in more detail in the section `Different outputs`_.


Post-processing outputs
~~~~~~~~~~~~~~~~~~~~~~~

XML output files that are generated during the test execution can be
post-processed afterwards by the :prog:`rebot` tool, which is an integral
part of Robot Framework. It is used automatically when test
reports and logs are generated during the test execution, but there
are also good grounds for using it separately.

Creating different reports and logs
'''''''''''''''''''''''''''''''''''

You can use :prog:`rebot` for creating the same reports and logs that
are created automatically during the test execution. Of course, it is
not sensible to create the exactly same files, but, for example,
having one report with all test cases and another with only a subset
of tests can be useful. Additionally, it is possible to create only
the output file when running tests and generate logs and reports
later. This is a good idea, for example, when running tests on Jython,
because the :prog:`rebot` tool always runs on Python, which is
slightly faster than Jython.

The basic syntax for using :prog:`rebot` is exactly the same as that
used with `starting test execution`_, and also most of the command
line options are the same. The difference is that arguments to
:prog:`rebot` are XML output files instead of test data files or
directories.

::

   rebot output.xml
   rebot --include smoke --name Smoke_Tests path/to/output.xml


Combining outputs
'''''''''''''''''

The most important feature of :prog:`rebot` is its ability to combine
outputs from different test executions. This capability allows, for
example, running the same test cases on different environments and
generating an overall report from all outputs. Combining outputs is
extremely easy, all that needs to be done is giving multiple output
files as arguments::

   rebot output1.xml output2.xml
   rebot outputs/*.xml

When outputs are combined, a new top-level test suite is created so
that test suites in given output files are its child suites. This
works the same way when `multiple test data files or directories are
executed`__, and also in this case the name of the top-level test
suite is created by joining child suite names with an ampersand (&)
and spaces. These automatically generated names are not that good, and
it is often a good idea to use :setting:`--name` to give a more
meaningful name::

   rebot --name Browser_compatibility firefox.xml opera.xml ie.xml

__ `Specifying the test data to be executed`_


Getting help on command line
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Both when executing test cases with :prog:`pybot` or :prog:`jybot` and
when post-processing reports with :prog:`rebot`, it is possible to get
command line help with the option :setting:`--help` and its short version
:setting:`-h`. These help texts have a short general overview and
briefly explain the available command line options.

All start-up scripts also support getting the version information with the
option :setting:`--version`. The information also contains the version
of the used interpreter and the operating system type.


Handling complicated options
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Many special characters are complicated to use on the command line.
Additionally, a normal space is problematic in an option value, because
it is used for separating options from each other. Escaping these
complicated characters with a backslash or quoting the values does not
always work, and Robot Framework has its own generic escaping
mechanism. It is also possible to use argument files where options can
be specified in plain text format. These systems work both when
executing tests and when post-processing outputs, and also some of the
external supporting tools have the same or similar capabilities.

Escaping options
''''''''''''''''

In Robot Framework's command line escaping mechanism
problematic characters are escaped with freely selected text. The
command line option to use is :setting:`--escape` (short version
:setting:`-E`), which takes an argument in the format :setting:`what:with`,
where :setting:`what` is the name of the character to escape and
:setting:`with` is the string to escape it with. Characters that can
be escaped are listed in the table below:

.. table:: Available escapes
   :class: tabular

   =========  =============  =========  =============
   Character   Name to use   Character   Name to use
   =========  =============  =========  =============
   &          amp            (          paren1
   '          apos           )          paren2
   @          at             %          percent
   \\         blash          \|         pipe
   :          colon          ?          quest
   ,          comma          "          quot
   {          curly1         ;          semic
   }          curly2         /          slash
   $          dollar         \          space
   !          exclam         [          square1
   >          gt             ]          square2
   #          hash           \*         star
   <          lt             \          \   
   =========  =============  =========  =============

The following examples make the syntax more clear. In the
first example, the metadata :setting:`X` gets the value :code:`Value with
spaces`, and in the second variable :var:`${VAR}` is assigned to
:code:`"Hello, world!"`.

::

    --escape space:_ --metadata X:Value_with_spaces
    -E space:SP -E quot:QU -E comma:CO -E exclam:EX -v VAR:QUHelloCOSPworldEXQU

Note that all the given command line arguments, including paths to test
data, are escaped. Escape character sequences thus need to be
selected carefully.


Using argument files
''''''''''''''''''''

Another possibility to handle complicated arguments is placing them
into a argument file and using :setting:`--argumentfile` (short
option :setting:`-A`) to specify the path to it, along with possible other
options. These files can contain both command line options and paths
to the test data, one per line. Argument files can contain any ASCII
characters without escaping, but spaces in the beginning and end
of lines are ignored. Additionally, empty lines and lines starting with
a hash mark (#) are ignored.

An example argument file::

   --doc This is an example (where "special characters" are ok!)
   --metadata X:Value with spaces
   --variable VAR:Hello, word!
   # This is a comment line
   path/to/test directory/

Argument files can be used either alone so that they contain all the
options and paths to the test data, or along with other options and
paths. When an argument file is used in the command line, its contents
are placed to the original list of arguments to the same place
where the argument file option was.

::

   pybot --argumentfile all_arguments.txt
   pybot --name example --argumentfile other_options_and_paths.txt
   pybot --argumentfile default_options.txt --name example my_tests.html
