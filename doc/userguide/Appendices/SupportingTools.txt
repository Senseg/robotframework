Supporting tools
----------------

In this appendix, the available supporting tools for Robot Framework
are described. Unless otherwise stated later in this chapter, the
tools can be downloaded from the `Robot Framework supporting tools page`_.

.. contents::
   :depth: 2 
   :local: 

Test data editing tool (Robot IDE)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Robot IDE is a standalone tool for editing test data. It helps in
creating, editing and maintaining of Robot Framework test
data.

.. figure:: Robot_IDE.png
   :width: 942
   :height: 683
  
   Robot IDE

However, the instructions for using Robot IDE are not within the
scope of this user guide; for more information on the tool, see `Robot
IDE wiki pages`_.

Start/End/Elapsed time reporting tool (times2csv.py)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

times2csv.py is a tool for creating a CSV file containing suite, test
and keyword execution times (Start/End/Elapsed time).

Usage
'''''

::

  times2csv.py input-xml [output-csv]

This script reads start, end, and elapsed times from all suites, tests and 
keywords in the given Robot output file and writes them into a file in the
comma-separated-values (CSV) format. If the CSV output file is not given, its 
name is obtained from the input file by replacing the :path:`.xml` extension with :path:`.csv`.

Manual test case execution tool (Mabot)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Mabot is used to manually "execute" the Robot test cases. Mabot
generates a similar XML as Robot in automated test execution. This
makes it possible to generate combined reports from the automated and
manual test executions with the existing tools, such as Rebot.

.. figure:: mabot.png
   :width: 860
   :height: 653

   Screenshot of Mabot 

Installation
''''''''''''

Mabot requires Robot 1.8, and version 1.8.2 is recommended. As an
external prerequisite, Python version 2.5 or newer must be used.

To install Mabot, go to the `Mabot page`_ on the Robot Framework site
and download the installer from there. The only difference between the
two installers available there is that the default settings can be
changed from the Settings menu.

There is no need to uninstall an older version before installing a new
version. Your settings will not be affected by the new installation.

Usage
'''''

Start Mabot by typing::

 python -m mabot 

You can also give options and path::

 python -m mabot [options] [path] 

where path can be a test suite (a directory or a file) or an output XML. 

See the options with the following command::

 python -m mabot --help 


Settings
''''''''

The following settings are available from the ``Settings`` menu:

    - ``Default Message``: This is the message that all not executed
      tests and keywords have. It will also appear when using the "Set
      Failed" function.
    - ``Add Test Executor Tag``: This setting defines whether or not to
      add a tag defined with the setting ``Test Executor Tag`` to
      modified test cases.
    - ``Test Executor Tag``: See the previous setting.
    - ``Always Load Old Data From Xml``: This setting defines if you want
      to read saved data from an XML when opening a file. It also changes
      the default output path to an XML file, even if an XML file
      does not exist. The XML file name is created in the following way:

      + :path:`.xml` is added to the directory path, for example
      	:path:`some/dir` becomes :path:`some/dir.xml`
      + in test data files, the file extension :path:`.html` is replaced with 
      	:path:`.xml`, for example :path:`my_tests.html` becomes :path:`my_tests.xml`

    - ``Include Tags``: Defines tags that are used to include tests when
      opening a test data file or directory.
    - ``Exclude Tags``: The same as ``Include Tags``, but for excluding tags.


Library documentation tool (libdoc.py)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Library documentation can generate library keyword documentation from
test libraries and resource files either in HTML or XML format. The
former is for humans and the latter mainly for Robot IDE or other
tools.

Usage
'''''

.. TODO: Change the formatting of the options below so that in the HTML file it looks the same as in CWiki. 
 
The usage printed with :cli:`python libdoc.py --help` should look something like below::


    $ python libdoc.py
    Robot Framework Library and Resource File Documentation Generator

    Usage:  libdoc.py [options] library_or_resource

    This script can generate keyword documentation in HTML or XML. The former is 
    for humans and the latter mainly for Robot IDE and other tools.

    Documentation can be created for

    - test libraries implemented with Python or Java using the normal library API,
    - test libraries using the dynamic API (but you only get keyword names and not
      their arguments or documentations), and
    - resource files.

    Options:

    -f --format html|xml	Specifies whether to generate HTML or XML output. The default value is HTML.

    -o --output path		Where to write the generated documentation. If the path is a directory, the documentation is generated there using the name "." with an index after the "" part, if a file with that name already exists. If the given path points to a file, this path is used as-is and possible existing file is overwritten. The default value for the path is the directory where the script is executed from.

    -P --pythonpath path *  Additional path(s) to insert into PYTHONPATH.

    -h -? --help            Print this help.

    It is possible to specify a Python test library by giving either the path to 
    the source or only the library name. If the library name is used, it must be in 
    the same format as in Robot test data when importing libraries. In this case, 
    the library is searched from PYTHONPATH (and from CLASSPATH, if on Jython). 

    A Java test library implemented with normal library API can be specified by 
    giving the path to the source file containing the library class. Additionally, 
    "tools.jar", which is part of the Sun JDK distribution, must be found from 
    CLASSPATH when libdoc.py is executed.

    Libraries using the dynamic library API are handled in the same way as Python 
    libraries are.

    Resource files must always be specified using a path. If the path does not 
    exist, resource files are also searched from all directories in PYTHONPATH.

    Examples:

     $ python path/to/libdoc.py OperatingSystem
     $ python path/to/libdoc.py --output doc/MyLib.html src/MyLib.py
     $ python path/to/libdoc.py test/resource.html
     $ python path/to/libdoc.py --format xml OperatingSystem
     $ python path/to/libdoc.py --format xml --output doc test/resource.html
     $ jython path/to/libdoc.py --format xml MyJavaLibrary.java


How imported libraries are found
''''''''''''''''''''''''''''''''  
 
The libraries to document are imported similarly as they are imported
when executing test cases. Libraries can only be imported if they are
found from PYTHONPATH (or from CLASSPATH when running with
Jython). PYTHONPATH (and/or the CLASSPATH) must thus be set correctly
before generating the documentation. An exception to this rule are
normal Java libraries; it is enough to give the path to the source
file for these.


Writing documentation
'''''''''''''''''''''
  
The documentation for Python libraries is written simply as doc
strings for the library class and for methods implementing
keywords. The first line of the method documentation is considered as
a short documentation for the keywords (used for example as a tool tip in
links in the generated HTML documentation), and it should thus be as
describing as possible but not too long. From Robot 1.4 onwards, it
is possible to use simple formatting in documentation (for example, bold and
tables).

The simple example below illustrates how to write the documentation,
and standard libraries (for example, OperatingSystemLibrary) give more
realistic examples. For more information on Python documentation
strings, see `PEP-257`_.

.. _PEP-257: http://www.python.org/dev/peps/pep-0257/

.. sourcecode:: python

	class ExampleLib:

    	    """Library for demo purposes.

    	    This library is only used in an example and does not do anything useful.
    	    """

    	    def my_keyword(self):
            	"""Does nothing."""
            	pass

    	    def your_keyword(self, arg):
            	"""Takes one argument and *does nothing* with it.

        	Example:
        	| Your Keyword | xxx |
        	| Your Keyword | yyy |
        	"""
        	pass

When writing documentation for a normal Java library, conventions for
writing Javadoc should be used. The documentation is generated based
on the Javadocs in the source files.


Download
''''''''
 
The script can be downloaded from
https://cwiki.nokia.com/twiki/pub/RobotFramework/LibraryDocumentationGeneration/libdoc.py.txt.

.. Note:: Because of TWiki security restrictions, the filename has a
   	  :path:`.txt` extension. That must be removed, so the file must be saved
 	  as :path:`libdoc.py`.


Tool for viewing debug files (fileviewer.py)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

File viewer is a tool designed to be used together with the Robot
Framework command line option :cli:`--debugfile`. The debug file can be
opened with File viewer, and the viewer will automatically update the
display as the debug file gets written, so that it is possible to
scroll the file when it is being written to.

The tool can be downloaded from here:
https://cwiki.nokia.com/twiki/pub/RobotFramework/FileViewerTool/fileviewer.py.txt

.. Note:: Because of TWiki security restrictions, the filename has a
   	  :path:`.txt` extension. That must be removed, so the file must be saved
 	  as :path:`fileviewer.py`.

To use the tool, you can either double-click the icon and click the
``Open`` button in the GUI to open the desired file, or you can start
the tool from the command line and give the path to the debug file as
an argument, for example::

   python fileviewer.py mydebugfile.txt

.. figure:: fileviewer.png
   :width: 754
   :height: 521

   File viewer


Javalibcore
~~~~~~~~~~~

Javalibcore is a common core for all Java libraries of Robot Framework. 

The main advantages of this core are: 

    - It is easily extensible and dynamic; you can add keywords to the class path. 
    - There is no need for a library; you can just implement keywords. 
    - There is common functionality readily available (for example, argument count checking for keywords) 

Robot Framework supports two kinds of Java libraries. The simpler way
is to have a single library class, which has keywords as methods. This
is a very easy way to get started, but as the number of keywords grows,
this approach soon leads to bad design and hard-to-maintain code, even if you
split the keywords into several classes.

The other, better way of doing this is to have a library that
implements the methods :code:`String[] getKeywordNames()` and
:code:`Object runKeyword(String keywordName, Object[]
arguments)`. This enables you to decide how you want to run and
implement your keywords.

Javalibcore provides an implementation of the latter library
model. You can add keywords either by simply implementing a Keyword
interface and having your classes in the classpath when running Robot Framework,
or by using Spring configuration files to wire them.


Provided libraries
'''''''''''''''''' 

These libraries do not provide any keywords. They are mere common
implementations of libraries so you do not need to create your own, but you only
need to write keyword implementations. The principle of how the libraries find the
keywords is explained below.

ClassPathLibrary
```````````````` 

ClassPathLibrary searches for keywords in the class path. The class
name is mapped to a keyword name. To create a keyword with the name
:kw:`Do My Specific Task`, you simply implement a keyword class called
DoMySpecificTask and add it to the class path.

A keyword implementation has to meet the following requirements: 

  - It is a class that implements the com.nokia.robot.javalib.core.keyword.Keyword interface. 
  - The name matches the pattern com/nokia/\**/keyword/\**/\**.class. 
  - The class has a default constructor. 
  - The class is public and non-abstract. 

See the Examples part in the Downloads section of `Javalib-core Wiki pages`__ to get started.

__ https://cwiki.nokia.com/RobotFramework/Javalib-core 

SpringLibrary
````````````` 

ClassPathLibrary maps one keyword to one class. It also limits the
implementation, because it requires a default constructor. If this is
a problem, you can use Spring configuration files to wire keywords any
way you want. Here is an example of a Spring configuration file:

::

 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN"
	 "http://www.springframework.org/dtd/spring-beans.dtd">

 <beans>
   <bean id="componentShouldBeVisible" class="com.nokia.oss.mycomponent.keyword.ComponentVisibility">
     <constructor-arg type="boolean" value="true">
   </bean>

   <bean id="componentShouldNotBeVisible" class="com.nokia.oss.mycomponent.keyword.ComponentVisibility">
     <constructor-arg type="boolean" value="false">
   </bean>
 </beans>

The pattern used to find configuration files is
com/nokia/\**/keywords.xml. Only beans of type
com.nokia.robot.javalib.core.keyword.Keyword are interpreted to be
keyword implementations.

For more information about Spring Framework, see http://www.springframework.org/. 


CompositeLibrary
````````````````
 
CompositeLibrary simply combines SpringLibrary and ClassPathLibrary. With CompositeLibrary, you can use either way to add new keywords. 


Common functionality 
''''''''''''''''''''
.. TODO: Add some short introductory text here.

ArgumentCheckingKeyword
```````````````````````
 
With a lot of keywords you want to check that you get the correct
number of arguments from the user. In Javalib-core, there is an abstract class
that you can extend to achieve this behavior. Please see the source
code for com.nokia.robot.javalib.core.keyword.ArgumentCheckingKeyword.


PreparableKeyword
````````````````` 

If your keyword needs to be prepared in some way for it to work, you
can use com.nokia.robot.core.keyword.PreparableKeyword. For example,
in the Prepare method you can check that the current context that you
are working in is correct for the keyword.


Historical reporting tool (risto.py)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
risto.py is a tool for plotting graphs about test execution history
based on statistics read from Robot output files.

Usage
''''' 

risto.py -- Robot Framework's Historical Reporting Tool

Version: 1.0

Usage:  risto.py options input files
  or:   risto.py options1 --- options2 --- optionsN --- input files
  or:   risto.py --argumentfile path

risto.py plots graphs about test execution history, based on statistics read
from Robot output files. By default, it draws total, passed and failed graphs
for critical tests and all tests, but it is possible to omit some of these
graphs and also to add graphs by tags. The actual drawing is handled by the Matplotlib
tool that must be installed separately. More information on Matplotlib, including
the installation instructions, can be found from http://matplotlib.sourceforge.net.

Names of test rounds that are shown on the x-axis are, by default, obtained from the
paths to input files. Alternatively, names can be obtained from the metadata of the
top level test suite (for more information, see Robot Framework's :cli:`--metadata` option).

Graphs are saved to a file specified with the :cli:`--output` option, and the output
format is determined by from the file extension. The supported formats depend on the installed
Matplotlib back-ends, but at least PNG ought to be always available. If the output
file is omitted, the graph is opened into Matplotlib's image viewer (which
requires Matplotlib to be installed with some graphical front-end).

It is possible to draw several graphs with different options at once. This is
done by separating different option groups with three or more hyphens (:cli:`---`).
Note that in this case, also paths to input files need to be separated from
the options similarly.

Instead of giving all options from the command line, it is possible to read them
from a file specified with the :cli:`--argument` option. In an argument file, options
and their possible arguments are listed one per line, and option groups are
separated with lines of three or more hyphens. Empty lines and lines starting
with a hash mark (#) are ignored. 

Options:

--nocritical

    Also -C. Specifies that graphs are not plot for critical tests.

--noall

    Also -A. Specifies that graphs are not plot for all tests.

--nototals

    Also -T. Specifies that total graphs are not plot.

--nopassed

    Also -P. Specifies that passed graphs are not plot.

--nofailed

    Also -F. Specifies that failed graphs not plot.

--tag

    Also -t. Takes name as argument. Adds graphs for these
    tags. The name can contain "\*" and "?" as
    wildcards. Underscores in the names are converted to spaces and
    additionally "AND" to "&".

--output

    Also -o. Takes path as argument. Specifies the path to
    the image file to create. If not given, the image is opened into
    Matplotlib's viewer.

--title

    Also -i. Takes title as argument. Specifies the title of
    the graph. Underscores in the given title are converted to
    spaces. By default, there is no title.

--width

    Also -w. Takes inches as argument. Specifies the width of
    the image. The default is 800.

--height

    Also -h. Takes inches as argument. Specifies the height
    of the image. The default is 400.

--font

    Also -f. Takes size as argument. Specifies the font size
    used for legends and labels. The default is 8.

--marker size    

    Also -m. The size of marker used with tag graphs. The default is 5.

--xticks

    Also -x. Takes num as argument. Specifies the maximum
    number of ticks on the x-axis. The default is 15.

--namemeta

    Also -n. Takes name as argument. Specifies the name of
    the metadata of the top level test suite where to get name of
    the test round. By default names are got from paths to input
    files.

.. TODO: Change the formatting so that the options below look OK in the HTML file.
  
---
 
    Used to group options to create several images at once.

--argumentfile
 
    Takes path as argument. Reads the command line arguments from the specified file.

--verbose

    Specifies the verbose output.
 
--help

    Prints the help.

 --version

    Prints the version information.


Examples:

.. sourcecode:: python

	risto.py --output history.png output1.xml output2.xml output3.xml
  		risto.py --title My_Report --noall --namemeta Date --output out.png \*.xml
  	risto.py --nopassed --tag smoke --tag iter-* results/\*/output.xml
  	risto.py -CAP -t tag1 --- -CAP -t tag2 --- -CAP -t tag3 --- outputs/*.xml
  	risto.py --argumentfile arguments.txt

 	 ====[arguments.txt]===================
  	--title Overview
  	--output overview.png
  	----------------------
  	--nocritical
  	--noall
  	--nopassed
  	--tag smoke1
  	--title Smoke Tests
  	--output smoke.png
  	----------------------
  	path/to/*.xml
  	======================================

Installation
''''''''''''

Here you can find the instructions for the installation of risto.py. 

Preconditions
`````````````
 
risto.py requires Python. It has been tested both on releases 2.4 and
2.5, and it should work also in 2.3. Also some Robot modules are
needed, and thus some Robot Framework 1.8 version needs to be
installed.

The Matplotlib tool is used for plotting graphs, and it needs to be
installed separately. Matplotlib has its own preconditions, and at
least NumPy needs to be installed. The default Matplotlib installation
should always support at least PNG, but if more output formats are
needed, some extra back-ends may need to be installed. Additionally,
you may need to install graphical front-ends to be able to use
Matplotlib's own viewer for opening graphs without saving them to a
file.

risto.py reads statistics from output files using the ElementTree
module. Python 2.5 has this module in its standard library, but for
older versions, it needs to be installed separately.


Links to the needed software: 

- Matplotlib_

- NumPy_

- ElementTree_ 

- risto.py_ 

.. Note:: Because of TWiki security restrictions, the
   	  file name has a :path:`.txt` extension. That must be removed, so
   	  the file must be saved as :path:`risto.py`. After the downloading
   	  and renaming, you can run the tool simply like python
   	  risto.py arguments.


Screenshots
'''''''''''

Here you can find some screenshots of risto.py.

Default settings
````````````````
 
The screenshot below uses some very simple example outputs, thus the lines
are mainly straight. The default settings have been used otherwise,
but the output has been saved into a file with the :cli:`--output
default.png` option.

.. figure:: risto_default.png
   :width: 800
   :height: 400

   Simple example output

Various settings
````````````````
 
The example outputs used in this screenshot are the same as in the previous
one, but now the following options have been specified::

    --nopassed --noall --tag f1 --title Another_Example --width 600 --height 250 --font 6 --marker 3 --output another.png

.. figure:: risto_another.png
   :width: 600
   :height: 250
   
   Another example output

Using Matplotlib's Viewer
`````````````````````````
 
This time there are more input files and the image has been opened
into Matplotlib's viewer (that is, the :cli:`--output` option has not been
used). The options used to create this example are the ones below::

      -CAP -t d1_AND_d2 -t t1 -t sub3 -i Yet_Another_Example -x 20 -w 1000 -n Name

.. figure:: risto_yetanother.png
   :width: 820
   :height: 393

   More complex example output

More Realistic Examples
'''''''''''''''''''''''

These examples are generated from real test outputs using the following argument file: 

::

      --title Overview
      --output overview.png
      -----------------
      --title DRT Tests
      --nocritical
      --noall
      --tag phase-drt
      -nofailed
      --output drt.png 
      ------------------
      path/\*/output.xml

.. figure:: risto_overview.png
   :width: 800
   :height: 400

   Example overview

.. figure:: risto_drt.png
   :width: 800
   :height: 400

   Example DRT tests


.. _Robot IDE wiki pages: https://cwiki.nokia.com/RobotFramework/RobotIDE
.. _Mabot page: https://cwiki.nokia.com/RobotFramework/Mabot
.. _Matplotlib: http://matplotlib.sourceforge.net/
.. _NumPy: http://numpy.scipy.org/
.. _ElementTree: http://effbot.org/zone/element-index.htm
.. _risto.py: https://cwiki.nokia.com/twiki/pub/RobotFramework/HistoricalReporting/risto.py.txt
.. _Robot Framework supporting tools page: https://cwiki.nokia.com/RobotFramework/DownloadPage#Supporting_Tools 
